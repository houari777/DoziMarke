package main

import "core:fmt"
import "core:time"

// Simple map type for our data
DataMap :: map[string]f64

// =======================
// Data Structures
// =======================
StreakData :: struct {
    login: int,
    sales: int,
    activity: int,
    best_login: int,
    best_sales: int,
}

Achievement :: struct {
    id: string,
    name: string,
    category: string,
    xp_reward: int,
    unlocked_at: time.Time,
}

Badge :: struct {
    id: string,
    name: string,
    icon: string,
    tier: string,
    earned_at: time.Time,
}

ChallengeRewards :: struct {
    xp: int,
    coins: int,
    gems: int,
}

DailyChallenge :: struct {
    id: string,
    name: string,
    goal: int,
    progress: int,
    completed: bool,
    rewards: ChallengeRewards,
    expires_at: time.Time,
}

UserStatistics :: struct {
    total_sales: int,
    total_revenue: f64,
    average_rating: f64,
    response_time: f64,
    completion_rate: f64,
}

UserGamificationState :: struct {
    user_id: string,
    xp: int,
    level: int,
    coins: int,
    gems: int,
    streaks: StreakData,
    achievements: map[string]Achievement,
    badges: map[string]Badge,
    daily_challenges: [dynamic]DailyChallenge,
    statistics: UserStatistics,
    last_updated: time.Time,
}

LeaderboardEntry :: struct {
    user_id: string,
    name: string,
    xp: int,
    level: int,
    sales: int,
    rank: int,
    change: int,
    revenue: f64,
}

// =======================
// AI Model
// =======================
AIPersonalizationModel :: struct {
    weights: map[string]f64,
    biases: map[string]f64,
}

init_ai_model :: proc() -> AIPersonalizationModel {
    weights := make(map[string]f64)
    weights["price_sensitivity"] = 0.3
    weights["brand_loyalty"] = 0.2
    weights["category_preference"] = 0.25
    
    biases := make(map[string]f64)
    biases["base"] = 0.5
    
    model: AIPersonalizationModel
    model.weights = weights
    model.biases = biases
    return model
}

recommend_price :: proc(model: AIPersonalizationModel, base_cost: f64) -> f64 {
    return base_cost * (1.0 + model.weights["price_sensitivity"]) + model.biases["base"]
}

// =======================
// Global Variables
// =======================
user_cache: map[string]UserGamificationState
leaderboard_cache: [dynamic]LeaderboardEntry

// =======================
// Gamification Functions
// =======================
calculate_xp_for_action :: proc(action: string, data: DataMap, state: UserGamificationState) -> int {
    xp: int = 0
    
    if action == "sale_completed" {
        if amount, ok := data["amount"]; ok {
            xp = 10
            if amount > 1000 { xp += 40 }
            if amount > 5000 { xp += 100 }
        }
    } else if action == "product_added" {
        xp = 5
    } else if action == "review_received" {
        if rating, ok := data["rating"]; ok {
            xp = int(rating * 4)
        }
    } else if action == "daily_login" {
        xp = state.streaks.login * 5
    }
    
    multiplier := 1.0 + (f64(state.streaks.login) * 0.01)
    return int(f64(xp) * multiplier)
}

// calculate_level function is defined only once

get_user_name :: proc(user_id: string) -> string { 
    return "ØªØ§Ø¬Ø±" 
}
grant_level_rewards :: proc(state: ^UserGamificationState, level: int) {
    if level == 5 {
        state.coins += 500
    } else if level == 10 {
        state.coins += 1500
        state.gems += 5
    } else if level == 20 {
        state.coins += 5000
        state.gems += 20
    } else if level == 50 {
        state.gems += 100
    }
}

save_to_database :: proc(state: UserGamificationState) { 
    fmt.println("ğŸ’¾ Saving state:", state.user_id, "XP:", state.xp) 
}

send_realtime_update :: proc(user_id: string, message: string) { 
    fmt.println("ğŸ”” Update for user", user_id, ":", message) 
}

update_leaderboard :: proc(state: ^UserGamificationState) {
    found := false
    for &entry, i in leaderboard_cache {
        if entry.user_id == state.user_id {
            old_rank := entry.rank
            entry.xp = state.xp
            entry.level = state.level
            entry.sales = state.statistics.total_sales
            entry.revenue = state.statistics.total_revenue
            
            // Re-sort the leaderboard
            sort_leaderboard()
            
            // Update the change in rank
            entry.change = old_rank - find_rank(state.user_id)
            found = true
            break
        }
    }
    
    if !found {
        // Add new entry to leaderboard
        new_entry := LeaderboardEntry{
            user_id = state.user_id,
            name = fmt.tprint("User ", state.user_id),
            xp = state.xp,
            level = state.level,
            sales = state.statistics.total_sales,
            revenue = state.statistics.total_revenue,
            rank = 0,
            change = 0,
        }
        append(&leaderboard_cache, new_entry)
        sort_leaderboard()
    }
}

sort_leaderboard :: proc() {
    n := len(leaderboard_cache)
    
    // Simple bubble sort for demonstration
    for i in 0..<n-1 {
        for j in 0..<n-i-1 {
            if leaderboard_cache[j].xp < leaderboard_cache[j+1].xp {
                leaderboard_cache[j], leaderboard_cache[j+1] = leaderboard_cache[j+1], leaderboard_cache[j]
            }
        }
    }
    
    // Update ranks
    for &entry, i in leaderboard_cache {
        entry.rank = i + 1
    }
}

find_rank :: proc(user_id: string) -> int {
    for entry, i in leaderboard_cache {
        if entry.user_id == user_id {
            return i + 1
        }
    }
    return 0
}

calculate_level :: proc(xp: int) -> int {
    level := 1
    xp_needed := 1000
    
    for xp >= xp_needed {
        level += 1
        xp_needed += level * 1000
        
        if level >= 100 {
            return 100
        }
    }
    
    return level
}

// =======================
// Leaderboard
// =======================
// Leaderboard functions are defined above

// sort_leaderboard function is defined only once

find_rank :: proc(user_id: string) -> int {
    for entry, i in leaderboard_cache {
        if entry.user_id == user_id {
            return i + 1
        }
    }
    return 0
}

// =======================
// Main
// =======================
main :: proc() {
    fmt.println("ğŸš€ Starting Gamification + AI + Leaderboard Engine...")
    
    // Initialize maps
    user_cache = make(map[string]UserGamificationState)
    leaderboard_cache = make([dynamic]LeaderboardEntry)
    
    // Initialize AI model
    ai_model := init_ai_model()
    user_id := "user_42"
    
    // Initialize user state
    streaks := StreakData{
        login = 10,
        sales = 0,
        activity = 0,
        best_login = 10,
        best_sales = 0,
    }
    
    state: UserGamificationState
    state.user_id = user_id
    state.xp = 1200
    state.level = 3
    state.coins = 500
    state.gems = 0
    state.streaks = streaks
    state.achievements = make(map[string]Achievement)
    state.badges = make(map[string]Badge)
    state.daily_challenges = make([dynamic]DailyChallenge)
    state.statistics = UserStatistics{}
    state.last_updated = time.now()

    // Process a sale
    data: DataMap
    data["amount"] = 1200.0
    
    xp := calculate_xp_for_action("sale_completed", data, state)
    state.xp += xp
    state.level = calculate_level(state.xp)

    // Add achievements
    new_achievements := make([dynamic]Achievement)
    if state.statistics.total_sales == 0 { // First sale
        achievement: Achievement
        achievement.id = "first_sale"
        achievement.name = "First Sale"
        achievement.category = "sales"
        achievement.xp_reward = 100
        achievement.unlocked_at = time.now()
        
        append(&new_achievements, achievement)
        
        // Add the achievement to the user's achievements
        for a in new_achievements {
            state.achievements[a.id] = a
            state.xp += a.xp_reward
        }
    }

    // AI price recommendation
    recommended_price := recommend_price(ai_model, 1200.0)
    fmt.println("ğŸ’¡ AI recommended price:", recommended_price)

    // Update leaderboard
    update_leaderboard(&state)

    // Save and send updates
    save_to_database(state)
    message := fmt.tprintf("Earned XP: %d, Recommended price: %.2f", xp, recommended_price)
    send_realtime_update(user_id, message)

    fmt.println("âœ… Ready")
    fmt.println("ğŸ† Leaderboard:")
    for entry in leaderboard_cache {
        fmt.println(entry.rank, "-", entry.name, "XP:", entry.xp)
    }
}
